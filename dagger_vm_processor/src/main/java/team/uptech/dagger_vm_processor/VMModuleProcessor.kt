package team.uptech.dagger_vm_processor

import com.google.auto.service.AutoService
import com.squareup.javapoet.*
import dagger.Module
import dagger.Provides
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.Processor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.AnnotationValue
import javax.lang.model.element.Modifier
import javax.lang.model.element.TypeElement
import javax.lang.model.type.ErrorType
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.SimpleAnnotationValueVisitor6
import javax.lang.model.util.SimpleTypeVisitor6

@SupportedSourceVersion(SourceVersion.RELEASE_8)
@AutoService(Processor::class)
class VMModuleProcessor : AbstractProcessor() {
    companion object {
        const val TYPE_PREFIX = "_ViewModelModule"
    }

    override fun getSupportedAnnotationTypes(): MutableSet<String> {
        return mutableSetOf<String>(
          ViewModelModule::class.java.canonicalName
        )
    }

    override fun process(
      annotations: MutableSet<out TypeElement>?,
      roundEnv: RoundEnvironment
    ): Boolean {
        try {
            val els = processingEnv.elementUtils
            roundEnv.getElementsAnnotatedWith(ViewModelModule::class.java)
                .forEach { el ->
                    el.annotationMirrors.forEach { mir ->
                        val annotation =
                            (mir.annotationType.asElement() as TypeElement).qualifiedName.toString()
                        if (annotation == ViewModelModule::class.java.canonicalName) {
                            val values = els.getElementValuesWithDefaults(mir)

                            val scope =
                                values.entries.firstOrNull { it.key.simpleName.contentEquals("scope") }
                                    ?.value
                                    ?.toMirrorValue() as MirrorValue.Type

                            val vms =
                                values.entries.firstOrNull { it.key.simpleName.contentEquals("viewModels") }
                                    ?.value
                                    ?.toMirrorValue() as MirrorValue.Array

                            val canonicalName = el.asType().toString()
                            val moduleName = "${canonicalName.substringAfterLast('.')}$TYPE_PREFIX"
                            val modulePackage = canonicalName.substringBeforeLast('.')
                            val type = build(
                              scope,
                              el.asType(),
                              moduleName,
                              vms.map {
                                val tName = TypeName.get(it as MirrorValue.Type).toString()
                                val packageName = tName.substringBeforeLast('.')
                                val vmName = tName.substringAfterLast('.')
                                BindVMFunctionSpec(
                                  ClassName.get(packageName, vmName)
                                )
                              }.toList()
                            )
                            JavaFile.builder(modulePackage, type) // 2
                                .addFileComment("Do not modify this! Generated by VMModuleProcessor")
                                .build()
                                .writeTo(processingEnv.filer)
                        }
                    }
                }
        } catch (ex: Exception) {
            ex.printStackTrace()
            return false
        }
        return true
    }

    private fun build(
      daggerScope: MirrorValue.Type,
      scope: TypeMirror,
      moduleName: String,
      list: List<BindVMFunctionSpec>
    ): TypeSpec {
        val tys = processingEnv.typeUtils
        val elm = processingEnv.elementUtils
        val element = tys.asElement(scope)

        val vmClassName = ClassName.get("androidx.lifecycle", "ViewModel")
        val genericType = TypeVariableName.get("T", vmClassName)
        val classClassName = ClassName.get("java.lang", "Class")
        val factoryClassName = ClassName.get("androidx.lifecycle.ViewModelProvider", "Factory")
        val providerClassName = ClassName.get("javax.inject", "Provider")
        val mapClassName = ClassName.get("java.util", "Map")
        val moduleScopeClassName = ClassName.get(
          elm.getPackageOf(element).toString(),
          element.simpleName.toString()
        )
        val daggerScopeClassName = with(TypeName.get(daggerScope).toString()) {
            ClassName.get(substringBeforeLast('.'), substringAfterLast('.'))
        }

        val returnType = ParameterizedTypeName.get(
          mapClassName,
          ParameterizedTypeName.get(
            classClassName,
            WildcardTypeName.subtypeOf(vmClassName)
          ),
          ParameterizedTypeName.get(
            providerClassName,
            vmClassName
          )
        )

        //Generating anonymous ViewModelProvider.Factory
        val factorySpec = TypeSpec.anonymousClassBuilder("")
            .addSuperinterface(factoryClassName)
            .addMethod(
              MethodSpec.methodBuilder("create")
                .addModifiers(Modifier.PUBLIC)
                .addAnnotation(Override::class.java)
                .addTypeVariable(genericType)
                .addParameter(
                  ParameterSpec.builder(
                    ParameterizedTypeName.get(
                      classClassName, TypeVariableName.get("T")
                    ), "modelClass"
                  )
                    .build()
                )
                .addStatement("return (T) viewModelMap.get(modelClass).get()")
                .returns(TypeVariableName.get("T"))
                .build()
            )
            .build()

        return TypeSpec.classBuilder(moduleName) // 1 Generating Module
            .addModifiers(Modifier.PUBLIC)
            .addAnnotation(Module::class.java)
            .addMethod(
              MethodSpec.methodBuilder("provide${moduleName}VMFactory")
                .addAnnotation(Provides::class.java)
                .addAnnotation(daggerScopeClassName)
                .addAnnotation(moduleScopeClassName)
                .addParameter(
                  ParameterSpec.builder(returnType, "viewModelMap")
                    .addAnnotation(moduleScopeClassName)
                    .build()
                )
                .returns(factoryClassName)
                .addStatement("return \$L", factorySpec)
                .build()
            )
            .addMethod(
              MethodSpec.methodBuilder("bind${moduleName}ViewModels")
                .addAnnotation(Provides::class.java)
                .addAnnotation(moduleScopeClassName)
                .addParameters(list.map {
                  ParameterSpec.builder(
                    ParameterizedTypeName.get(providerClassName, it.vmData),
                    it.vmData.simpleName()
                  ).build()
                })
                .returns(returnType)
                .addStatement(
                  CodeBlock.builder()
                    .add(" Map m = new \$T();\n", HashMap::class.java)
                    .add(
                      CodeBlock.join(
                        list.map {
                          CodeBlock.of(
                            "m.put(\$L.class,\$L);",
                            it.vmData.simpleName(),
                            it.vmData.simpleName()
                          )
                        }, "\n"
                      )
                    )
                    .add("\nreturn m")
                    .build()
                )
                .build()
            )
            .build()
    }

    private inner class BindVMFunctionSpec(
      val vmData: ClassName
    )
}


private object MirrorValueVisitor : SimpleAnnotationValueVisitor6<MirrorValue, Nothing?>() {
    override fun defaultAction(o: Any, ignored: Nothing?) = MirrorValue.Unmapped

    override fun visitType(mirror: TypeMirror, ignored: Nothing?) = mirror.accept(TypeVisitor, null)

    override fun visitArray(values: List<AnnotationValue>, ignored: Nothing?) =
        MirrorValue.Array(values.map { it.accept(this, null) })
}

sealed class MirrorValue {
    data class Type(private val value: TypeMirror) : MirrorValue(), TypeMirror by value
    data class Array(private val value: List<MirrorValue>) : MirrorValue(),
        List<MirrorValue> by value

    object Unmapped : MirrorValue()
    object Error : MirrorValue()
}

private object TypeVisitor : SimpleTypeVisitor6<MirrorValue, Nothing?>() {
    override fun visitError(type: ErrorType, ignored: Nothing?) = MirrorValue.Error
    override fun defaultAction(type: TypeMirror, ignored: Nothing?) = MirrorValue.Type(type)
}

fun AnnotationValue.toMirrorValue(): MirrorValue = accept(MirrorValueVisitor, null)